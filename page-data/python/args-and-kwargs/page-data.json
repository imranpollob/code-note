{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/python/args-and-kwargs/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"*args and **kwargs - packing and unpacking arguments\",\n  \"tags\": [\"python\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"packing-and-unpacking-arguments\"\n  }, \"Packing and Unpacking arguments\"), mdx(\"p\", null, \"We use two operators \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" for tuples, lists and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**\"), \" for dictionaries.\"), mdx(\"h3\", {\n    \"id\": \"unpacking-arguments\"\n  }, \"Unpacking arguments\"), mdx(\"p\", null, \"We can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" to unpack the list so that all elements of it can be passed as different parameters.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# Function that takes 4 arguments and prints them \\ndef fun(a, b, c, d): \\n    print(a, b, c, d) \\n  \\nmy_list = [1, 2, 3, 4] \\n  \\n# Unpacking list into four arguments \\nfun(*my_list)\\n# (1, 2, 3, 4)\\n\")), mdx(\"p\", null, \"For dictionary we will use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# Unpacking of dictionary items using ** \\ndef fun(a, b, c): \\n    print(a, b, c) \\n  \\n# A call with unpacking of dictionary \\nd = {'a':2, 'b':4, 'c':10} \\nfun(**d) \\n# 2 4 10\\n\")), mdx(\"h3\", {\n    \"id\": \"packing-arguments\"\n  }, \"Packing arguments\"), mdx(\"p\", null, \"When we don\\u2019t know how many arguments need to be passed to a python function, we can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" to pack all arguments in a tuple.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# This function uses packing to sum \\n# unknown number of arguments \\ndef mySum(*args): \\n    sum = 0\\n    for i in range(0, len(args)): \\n        sum = sum + args[i] \\n    return sum \\n  \\nprint(mySum(1, 2, 3, 4, 5)) \\nprint(mySum(10, 20)) \\n# 15\\n# 30\\n\")), mdx(\"p\", null, \"For dictionary we will use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# Packing of dictionary items using ** \\ndef fun(**kwargs): \\n    for key in kwargs: \\n        print(\\\"%s = %s\\\" % (key, kwargs[key])) \\n\\nfun(name=\\\"geeks\\\", ID=\\\"101\\\", language=\\\"Python\\\")\\n# language = Python\\n# name = geeks\\n# ID = 101\\n\")), mdx(\"h2\", {\n    \"id\": \"args-and-kwargs\"\n  }, \"*args and **kwargs\"), mdx(\"p\", null, \"These utilizes arguments \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"unpacking\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \" are mostly used in function definitions. You could have also written \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*var\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**vars\"), \". Writing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \" is just a convention.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \" allow you to pass a variable number of arguments to a function.\"), mdx(\"h2\", {\n    \"id\": \"usage-of-args\"\n  }, \"Usage of *args\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" is used to send a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"non-keyworded\"), \" variable length argument list to the function.\"), mdx(\"p\", null, \"Here\\u2019s an example to help you get a clear idea:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def test_var_args(f_arg, *argv):\\n    print(\\\"first normal arg:\\\", f_arg)\\n    for arg in argv:\\n        print(\\\"another arg through *argv:\\\", arg)\\n\\ntest_var_args('yasoob', 'python', 'eggs', 'test')\\n\\n# first normal arg: yasoob\\n# another arg through *argv: python\\n# another arg through *argv: eggs\\n# another arg through *argv: test\\n\")), mdx(\"p\", null, \"I hope this cleared away any confusion that you had.\"), mdx(\"h2\", {\n    \"id\": \"usage-of-kwargs\"\n  }, \"Usage of **kwargs\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \" allows you to pass \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"keyworded\"), \" variable length of arguments to a function. You should use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \" if you want to handle named arguments in a function. \"), mdx(\"p\", null, \"Here is an example to get you going with it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def greet_me(**kwargs):\\n    for key, value in kwargs.items():\\n        print(\\\"{0} = {1}\\\".format(key, value))\\n\\ngreet_me(name=\\\"yasoob\\\", age=21)\\n# name = yasoob\\n# age = 21\\n\")), mdx(\"p\", null, \"This is just the basics of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \" and you can see how useful it is.\"), mdx(\"h2\", {\n    \"id\": \"using-args-and-kwargs\"\n  }, \"Using *args and **kwargs\"), mdx(\"p\", null, \"Now that you have learned what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \" are for, you are ready to start writing functions that take a varying number of input arguments. \"), mdx(\"p\", null, \"But what if you want to create a function that takes a changeable number of both positional and named arguments?\"), mdx(\"p\", null, \"In this case, you have to bear in mind that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"order matters\"), \". Just as non-default arguments have to precede default arguments, so \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*args\"), \" must come before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"**kwargs\"), \".\"), mdx(\"p\", null, \"To recap, the correct order for your parameters is:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Standard arguments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"*args\"), \" arguments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"**kwargs\"), \" arguments\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# correct_function_definition.py\\ndef my_function(a, b, *args, **kwargs):\\n    pass\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The most common use case is when making function decorators\")), mdx(\"h2\", {\n    \"id\": \"fancy-uses-of-unpacking-operator\"\n  }, \"Fancy uses of unpacking operator\"), mdx(\"h3\", {\n    \"id\": \"print-unpacking-list\"\n  }, \"Print unpacking list\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"my_list = [1, 2, 3]\\n\\nprint(*my_list)\\n# 1 2 3\\n\\nprint(*my_list, sep=\\\", \\\")\\n# 1, 2, 3\\n\")), mdx(\"h3\", {\n    \"id\": \"unpack-and-assign-to-variable\"\n  }, \"Unpack and assign to variable\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"my_list = [1, 2, 3, 4, 5, 6]\\n\\na, *b, c = my_list\\n\\nprint(a)\\nprint(b)\\nprint(c)\\n# 1\\n# [2, 3, 4, 5]\\n# 6\\n\")), mdx(\"h3\", {\n    \"id\": \"merging-lists\"\n  }, \"Merging lists\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"my_first_list = [1, 2, 3]\\nmy_second_list = [4, 5, 6]\\nmy_merged_list = [*my_first_list, *my_second_list]\\n\\nprint(my_merged_list)\\n# [1, 2, 3, 4, 5, 6]\\n\")), mdx(\"h3\", {\n    \"id\": \"merging-dictionaries\"\n  }, \"Merging dictionaries\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"my_first_dict = {\\\"A\\\": 1, \\\"B\\\": 2}\\nmy_second_dict = {\\\"C\\\": 3, \\\"D\\\": 4}\\nmy_merged_dict = {**my_first_dict, **my_second_dict}\\n\\nprint(my_merged_dict)\\n# {'A': 1, 'B': 2, 'C': 3, 'D': 4}\\n\")), mdx(\"h3\", {\n    \"id\": \"string-to-list\"\n  }, \"String to list\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" operator works on any \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"iterable\"), \" object, and string is an iterable object\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"a = [*\\\"RealPython\\\"]\\nprint(a)\\n# ['R', 'e', 'a', 'l', 'P', 'y', 't', 'h', 'o', 'n']\\n\")), mdx(\"p\", null, \"Another, fancy one liner\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-py\"\n  }), \"*a, = \\\"RealPython\\\"\\nprint(a)\\n# ['R', 'e', 'a', 'l', 'P', 'y', 't', 'h', 'o', 'n']\\n\")), mdx(\"p\", null, \"There\\u2019s the unpacking operator \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \", followed by a variable, a comma, and an assignment. That\\u2019s a lot packed into one line! In fact, this code is no different from the previous example. It just takes the string RealPython and assigns all the items to the new list a, thanks to the unpacking operator \"), \".\"), mdx(\"p\", null, \"The comma after the a does the trick. When you use the unpacking operator with variable assignment, Python requires that your resulting variable is either a list or a tuple. With the trailing comma, you have actually defined a tuple with just one named variable a.\"), mdx(\"p\", null, \"While this is a neat trick, many Pythonistas would not consider this code to be very readable. As such, it\\u2019s best to use these kinds of constructions sparingly.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"*args and **kwargs - packing and unpacking arguments","tags":["python"],"emoji":null,"link":null},"fields":{"dateModified":"Jul 29, 2020 9:55 AM","modifiedTimestamp":"2020-07-29T09:55:55.000Z","slug":"/python/args-and-kwargs/"},"tableOfContents":{"items":[{"url":"#packing-and-unpacking-arguments","title":"Packing and Unpacking arguments","items":[{"url":"#unpacking-arguments","title":"Unpacking arguments"},{"url":"#packing-arguments","title":"Packing arguments"}]},{"url":"#args-and-kwargs","title":"*args and **kwargs"},{"url":"#usage-of-args","title":"Usage of *args"},{"url":"#usage-of-kwargs","title":"Usage of **kwargs"},{"url":"#using-args-and-kwargs","title":"Using *args and **kwargs"},{"url":"#fancy-uses-of-unpacking-operator","title":"Fancy uses of unpacking operator","items":[{"url":"#print-unpacking-list","title":"Print unpacking list"},{"url":"#unpack-and-assign-to-variable","title":"Unpack and assign to variable"},{"url":"#merging-lists","title":"Merging lists"},{"url":"#merging-dictionaries","title":"Merging dictionaries"},{"url":"#string-to-list","title":"String to list"}]}]},"parent":{"__typename":"File","relativePath":"python/args-and-kwargs.md"}}},"pageContext":{"id":"0a66cc4b-9583-5a3f-a371-497e472d3f8f","previous":{"id":"f9920989-a81f-5423-8681-caabbba178ce","frontmatter":{"title":"Lambda function","tags":["python"]},"fields":{"slug":"/python/lambda-function/","dateModified":"2020-07-29T09:55:55.000Z"}},"next":{"id":"e97bc87a-4592-5892-baa1-549d6f8067d7","frontmatter":{"title":"Set your goal, Use your time effectively","tags":["productivity"]},"fields":{"slug":"/productivity/set-your-goal-use-you-time-effectively/","dateModified":"2020-07-29T09:55:55.000Z"}},"hasUntagged":false,"basePath":"/"}},"staticQueryHashes":["1437003973","2744905544","3664657028","467212769","467212769"]}